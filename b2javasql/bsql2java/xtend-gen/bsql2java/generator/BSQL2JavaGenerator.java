/**
 * generated by Xtext 2.10.0
 */
package bsql2java.generator;

import bsql2java.bSQL2Java.BParameter;
import bsql2java.bSQL2Java.BSOperation;
import bsql2java.bSQL2Java.BSQLMachine;
import bsql2java.bSQL2Java.BType;
import bsql2java.bSQL2Java.BoolOperation;
import bsql2java.bSQL2Java.VoidOperation;
import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class BSQL2JavaGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<BSQLMachine> _filter = Iterables.<BSQLMachine>filter(_iterable, BSQLMachine.class);
    for (final BSQLMachine t : _filter) {
      String _m_name = t.getM_name();
      String _plus = (_m_name + ".java");
      CharSequence _compile = this.compile(t);
      fsa.generateFile(_plus, _compile);
    }
  }
  
  public CharSequence compile(final BSQLMachine m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//JAVA code of ");
    String _m_name = m.getM_name();
    _builder.append(_m_name, "");
    _builder.newLineIfNotEmpty();
    _builder.append("import java.sql.CallableStatement;");
    _builder.newLine();
    _builder.append("import java.sql.Connection;");
    _builder.newLine();
    _builder.append("import java.sql.ResultSet;");
    _builder.newLine();
    _builder.append("import java.sql.SQLException;");
    _builder.newLine();
    _builder.append("public class ");
    String _m_name_1 = m.getM_name();
    _builder.append(_m_name_1, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("private Connection dbcon;");
    _builder.newLine();
    {
      EList<BSOperation> _ops = m.getOps();
      for(final BSOperation o : _ops) {
        CharSequence _compile = this.compile(o);
        _builder.append(_compile, "");
        _builder.newLineIfNotEmpty();
        _builder.append("\t    \t");
      }
    }
    _builder.append("}");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final BSOperation o) {
    StringConcatenation _builder = new StringConcatenation();
    BoolOperation _bop = o.getBop();
    CharSequence _compile = this.compile(_bop);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    VoidOperation _vop = o.getVop();
    CharSequence _compile_1 = this.compile(_vop);
    _builder.append(_compile_1, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final BoolOperation bo) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\t");
    _builder.append("public boolean ");
    String _op_name = bo.getOp_name();
    _builder.append(_op_name, "\t");
    _builder.append("(");
    {
      EList<BParameter> _params = bo.getParams();
      boolean _hasElements = false;
      for(final BParameter p : _params) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t");
        }
        _builder.append(" ");
        BType _type = p.getType();
        CharSequence _btype2javatype = this.btype2javatype(_type);
        _builder.append(_btype2javatype, "\t");
        _builder.append(" ");
        String _p_name = p.getP_name();
        _builder.append(_p_name, "\t");
        _builder.append(" ");
      }
    }
    _builder.append(") {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("CallableStatement statem;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try{");
    _builder.newLine();
    _builder.append("\t\t   ");
    _builder.append("statem = dbcon.prepareCall(\"{call ");
    String _op_name_1 = bo.getOp_name();
    _builder.append(_op_name_1, "\t\t   ");
    _builder.append(" (?)}\");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t   \t\t");
    int index = 0;
    _builder.newLineIfNotEmpty();
    {
      EList<BParameter> _params_1 = bo.getParams();
      boolean _hasElements_1 = false;
      for(final BParameter p_1 : _params_1) {
        if (!_hasElements_1) {
          _hasElements_1 = true;
        } else {
          _builder.appendImmediate(";", "\t   \t\t");
        }
        _builder.append("\t   \t\t");
        _builder.append("statem.");
        BType _type_1 = p_1.getType();
        CharSequence _btype2javatypesetting = this.btype2javatypesetting(_type_1);
        _builder.append(_btype2javatypesetting, "\t   \t\t");
        _builder.append("(");
        _builder.append(index = (index + 1), "\t   \t\t");
        _builder.append(",");
        String _p_name_1 = p_1.getP_name();
        _builder.append(_p_name_1, "\t   \t\t");
        _builder.append("); ");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t   \t\t");
    _builder.append("//execution of the statement, returns true if the");
    _builder.newLine();
    _builder.append("\t   \t\t");
    _builder.append("//result of the query is empty");
    _builder.newLine();
    _builder.append("\t   \t\t");
    _builder.append("ResultSet res = statem.executeQuery();");
    _builder.newLine();
    _builder.append("\t   \t\t");
    _builder.append("return (res.getInt(1)==0);");
    _builder.newLine();
    _builder.append("\t   \t");
    _builder.append("}catch (SQLException e){};");
    _builder.newLine();
    _builder.append("\t   \t");
    _builder.append("return false;");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence btype2javatype(final BType t) {
    StringConcatenation _builder = new StringConcatenation();
    String _switchResult = null;
    String _type_name = t.getType_name();
    switch (_type_name) {
      case "NAT":
        _switchResult = "int";
        break;
      case "BOOL":
        _switchResult = "boolean";
        break;
      case "STR":
        _switchResult = "String";
        break;
      default:
        _switchResult = "int";
        break;
    }
    _builder.append(_switchResult, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence btype2javatypesetting(final BType t) {
    StringConcatenation _builder = new StringConcatenation();
    String _switchResult = null;
    String _type_name = t.getType_name();
    switch (_type_name) {
      case "NAT":
        _switchResult = "setInt";
        break;
      case "BOOL":
        _switchResult = "setBoolean";
        break;
      case "STR":
        _switchResult = "setString";
        break;
      default:
        _switchResult = "setInt";
        break;
    }
    _builder.append(_switchResult, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final VoidOperation vo) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("TO DO...");
    _builder.newLine();
    return _builder;
  }
}
