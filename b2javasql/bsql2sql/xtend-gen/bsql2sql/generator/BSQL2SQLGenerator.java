/**
 * generated by Xtext 2.10.0
 */
package bsql2sql.generator;

import bsql2sql.bSQL2SQL.Attribute;
import bsql2sql.bSQL2SQL.BParameter;
import bsql2sql.bSQL2SQL.BPredicate;
import bsql2sql.bSQL2SQL.BSOperation;
import bsql2sql.bSQL2SQL.BSQLMachine;
import bsql2sql.bSQL2SQL.BTable;
import bsql2sql.bSQL2SQL.BType;
import bsql2sql.bSQL2SQL.BoolOperation;
import bsql2sql.bSQL2SQL.SQLCall;
import bsql2sql.bSQL2SQL.TIAssignment;
import bsql2sql.bSQL2SQL.TableInstance;
import bsql2sql.bSQL2SQL.VoidOperation;
import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class BSQL2SQLGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<BSQLMachine> _filter = Iterables.<BSQLMachine>filter(_iterable, BSQLMachine.class);
    for (final BSQLMachine t : _filter) {
      String _m_name = t.getM_name();
      String _plus = (_m_name + ".sql");
      CharSequence _compile = this.compile(t);
      fsa.generateFile(_plus, _compile);
    }
  }
  
  public CharSequence compile(final BSQLMachine m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("--SQL code of ");
    String _m_name = m.getM_name();
    _builder.append(_m_name, "");
    _builder.newLineIfNotEmpty();
    BTable _inv = m.getInv();
    CharSequence _compile = this.compile(_inv);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    {
      EList<BSOperation> _ops = m.getOps();
      for(final BSOperation o : _ops) {
        CharSequence _compile_1 = this.compile(o);
        _builder.append(_compile_1, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compile(final BSOperation o) {
    StringConcatenation _builder = new StringConcatenation();
    BoolOperation _bop = o.getBop();
    CharSequence _compile = this.compile(_bop);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    VoidOperation _vop = o.getVop();
    CharSequence _compile_1 = this.compile(_vop);
    _builder.append(_compile_1, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final VoidOperation vo) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("TO DO...");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final BoolOperation bo) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("--generation of the operation ");
    String _op_name = bo.getOp_name();
    _builder.append(_op_name, "");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("CREATE PROCEDURE ");
    String _op_name_1 = bo.getOp_name();
    _builder.append(_op_name_1, "\t");
    _builder.newLineIfNotEmpty();
    {
      EList<BParameter> _params = bo.getParams();
      boolean _hasElements = false;
      for(final BParameter p : _params) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        _builder.append("\t\t");
        _builder.append("@");
        String _p_name = p.getP_name();
        _builder.append(_p_name, "\t\t");
        _builder.append(" ");
        BType _type = p.getType();
        CharSequence _compile2sql = this.compile2sql(_type);
        _builder.append(_compile2sql, "\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("   \t\t");
      }
    }
    _builder.append(",");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("@res INT OUTPUT");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("AS");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("BEGIN");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("SELECT @res = COUNT(*) ");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("FROM ");
    {
      TableInstance _objTable = bo.getObjTable();
      String _ti_name = _objTable.getTi_name();
      TableInstance _objTable_1 = bo.getObjTable();
      TIAssignment _ti_type = _objTable_1.getTi_type();
      String _instance_name = _ti_type.getInstance_name();
      boolean _equals = _ti_name.equals(_instance_name);
      if (_equals) {
        TableInstance _objTable_2 = bo.getObjTable();
        TIAssignment _ti_type_1 = _objTable_2.getTi_type();
        String _instance_type = _ti_type_1.getInstance_type();
        _builder.append(_instance_type, "\t\t\t\t");
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t\t");
    _builder.append("WHERE ");
    {
      EList<BPredicate> _pres = bo.getPres();
      boolean _hasElements_1 = false;
      for(final BPredicate p_1 : _pres) {
        if (!_hasElements_1) {
          _hasElements_1 = true;
        } else {
          _builder.appendImmediate(" AND", "\t\t\t\t");
        }
        _builder.append(" ");
        SQLCall _pLeft = p_1.getPLeft();
        String _sRight = _pLeft.getSRight();
        _builder.append(_sRight, "\t\t\t\t");
        _builder.append(" =    \t\t\t\t   \t\t  \t\t\t\t   \t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t\t\t");
        _builder.append("   \t\t");
        {
          String _pRight = p_1.getPRight();
          boolean _equals_1 = _pRight.equals("FALSE");
          if (_equals_1) {
            _builder.append(" 0");
            _builder.newLineIfNotEmpty();
            _builder.append("\t\t\t\t");
            _builder.append("   \t\t");
          } else {
            String _pRight_1 = p_1.getPRight();
            boolean _equals_2 = _pRight_1.equals("TRUE");
            if (_equals_2) {
              _builder.append(" 1");
              _builder.newLineIfNotEmpty();
              _builder.append("\t\t\t\t");
              _builder.append("   \t\t");
            } else {
              String _pRight_2 = p_1.getPRight();
              if ((_pRight_2 instanceof String)) {
                _builder.append(" @");
                String _pRight_3 = p_1.getPRight();
                _builder.append(_pRight_3, "\t\t\t\t   \t\t");
                _builder.newLineIfNotEmpty();
                _builder.append("\t\t\t\t");
                _builder.append("   \t\t");
              } else {
                _builder.append(" ");
                String _pRight_4 = p_1.getPRight();
                _builder.append(_pRight_4, "\t\t\t\t   \t\t");
                _builder.append(" ");
              }
            }
          }
        }
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t\t\t");
    _builder.append("END");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("GO");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final BTable t) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/*generation of the SQL table from the B variable ");
    String _table_name = t.getTable_name();
    _builder.append(_table_name, "");
    _builder.append("*/\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("CREATE TABLE ");
    String _table_name_1 = t.getTable_name();
    _builder.append(_table_name_1, "\t\t");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("/*they key is the first attribute*/");
    _builder.newLine();
    _builder.append("\t\t\t");
    EList<Attribute> _attributes = t.getAttributes();
    Attribute first = IterableExtensions.<Attribute>head(_attributes);
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t \t");
    CharSequence _compile = this.compile(first);
    _builder.append(_compile, "\t\t\t \t");
    _builder.append(" PRIMARY KEY NOT NULL ");
    _builder.newLineIfNotEmpty();
    {
      EList<Attribute> _attributes_1 = t.getAttributes();
      boolean _hasElements = false;
      for(final Attribute a : _attributes_1) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t     ");
        }
        {
          boolean _equals = a.equals(first);
          if (_equals) {
          } else {
            _builder.append("\t     ");
            CharSequence _compile_1 = this.compile(a);
            _builder.append(_compile_1, "\t     ");
            _builder.append(" NOT NULL ");
          }
        }
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final Attribute a) {
    StringConcatenation _builder = new StringConcatenation();
    String _att_name = a.getAtt_name();
    _builder.append(_att_name, "");
    _builder.append(" ");
    BType _type = a.getType();
    CharSequence _compile2sql = this.compile2sql(_type);
    _builder.append(_compile2sql, "");
    return _builder;
  }
  
  public CharSequence compile2sql(final BType t) {
    StringConcatenation _builder = new StringConcatenation();
    String _switchResult = null;
    String _type_name = t.getType_name();
    switch (_type_name) {
      case "NAT":
        _switchResult = "INT";
        break;
      case "BOOL":
        _switchResult = "BOOLEAN";
        break;
      case "STR":
        _switchResult = "VARCHAR(25)";
        break;
      case "Users":
        _switchResult = "VARCHAR(25)";
        break;
      case "Roles":
        _switchResult = "VARCHAR(25)";
        break;
      default:
        _switchResult = "INT";
        break;
    }
    _builder.append(_switchResult, "");
    return _builder;
  }
}
