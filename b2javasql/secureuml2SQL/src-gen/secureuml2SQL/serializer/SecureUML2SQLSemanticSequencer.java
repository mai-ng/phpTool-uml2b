/*
 * generated by Xtext 2.10.0
 */
package secureuml2SQL.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import secureuml2SQL.secureUML2SQL.BConstant;
import secureuml2SQL.secureUML2SQL.BESet;
import secureuml2SQL.secureUML2SQL.BMachine;
import secureuml2SQL.secureUML2SQL.BProperties;
import secureuml2SQL.secureUML2SQL.BSet;
import secureuml2SQL.secureUML2SQL.BSetValue;
import secureuml2SQL.secureUML2SQL.BTuple;
import secureuml2SQL.secureUML2SQL.SecureUML2SQLPackage;
import secureuml2SQL.services.SecureUML2SQLGrammarAccess;

@SuppressWarnings("all")
public class SecureUML2SQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SecureUML2SQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SecureUML2SQLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SecureUML2SQLPackage.BCONSTANT:
				sequence_BConstant(context, (BConstant) semanticObject); 
				return; 
			case SecureUML2SQLPackage.BE_SET:
				sequence_BESet(context, (BESet) semanticObject); 
				return; 
			case SecureUML2SQLPackage.BMACHINE:
				sequence_BMachine(context, (BMachine) semanticObject); 
				return; 
			case SecureUML2SQLPackage.BPROPERTIES:
				sequence_BProperties(context, (BProperties) semanticObject); 
				return; 
			case SecureUML2SQLPackage.BSET:
				sequence_BSet(context, (BSet) semanticObject); 
				return; 
			case SecureUML2SQLPackage.BSET_VALUE:
				sequence_BSetValue(context, (BSetValue) semanticObject); 
				return; 
			case SecureUML2SQLPackage.BTUPLE:
				sequence_BTuple(context, (BTuple) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BConstant returns BConstant
	 *
	 * Constraint:
	 *     constant_name=ID
	 */
	protected void sequence_BConstant(ISerializationContext context, BConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SecureUML2SQLPackage.Literals.BCONSTANT__CONSTANT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecureUML2SQLPackage.Literals.BCONSTANT__CONSTANT_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBConstantAccess().getConstant_nameIDTerminalRuleCall_0(), semanticObject.getConstant_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BESet returns BESet
	 *
	 * Constraint:
	 *     (set_name=ID values+=BSetValue values+=BSetValue*)
	 */
	protected void sequence_BESet(ISerializationContext context, BESet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecureUML2SQL returns BMachine
	 *     BMachine returns BMachine
	 *
	 * Constraint:
	 *     (
	 *         m_name=ID 
	 *         esets+=BESet 
	 *         esets+=BESet* 
	 *         cons+=BConstant 
	 *         cons+=BConstant* 
	 *         pros+=BProperties 
	 *         pros+=BProperties*
	 *     )
	 */
	protected void sequence_BMachine(ISerializationContext context, BMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BProperties returns BProperties
	 *
	 * Constraint:
	 *     (cons=ID prop='{' pairs+=BTuple pairs+=BTuple*)
	 */
	protected void sequence_BProperties(ISerializationContext context, BProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BSetValue returns BSetValue
	 *
	 * Constraint:
	 *     value_name=ID
	 */
	protected void sequence_BSetValue(ISerializationContext context, BSetValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SecureUML2SQLPackage.Literals.BSET_VALUE__VALUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecureUML2SQLPackage.Literals.BSET_VALUE__VALUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBSetValueAccess().getValue_nameIDTerminalRuleCall_0(), semanticObject.getValue_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BSet returns BSet
	 *
	 * Constraint:
	 *     set_name=ID
	 */
	protected void sequence_BSet(ISerializationContext context, BSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SecureUML2SQLPackage.Literals.BSET__SET_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecureUML2SQLPackage.Literals.BSET__SET_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBSetAccess().getSet_nameIDTerminalRuleCall_0(), semanticObject.getSet_name());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BTuple returns BTuple
	 *
	 * Constraint:
	 *     (ran=ID dom=ID)
	 */
	protected void sequence_BTuple(ISerializationContext context, BTuple semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SecureUML2SQLPackage.Literals.BTUPLE__RAN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecureUML2SQLPackage.Literals.BTUPLE__RAN));
			if (transientValues.isValueTransient(semanticObject, SecureUML2SQLPackage.Literals.BTUPLE__DOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecureUML2SQLPackage.Literals.BTUPLE__DOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBTupleAccess().getRanIDTerminalRuleCall_0_0(), semanticObject.getRan());
		feeder.accept(grammarAccess.getBTupleAccess().getDomIDTerminalRuleCall_2_0(), semanticObject.getDom());
		feeder.finish();
	}
	
	
}
