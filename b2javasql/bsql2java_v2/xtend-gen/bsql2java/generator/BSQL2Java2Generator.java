/**
 * generated by Xtext 2.10.0
 */
package bsql2java.generator;

import bsql2java.bSQL2Java2.Attribute;
import bsql2java.bSQL2Java2.BOperation;
import bsql2java.bSQL2Java2.BParameterTyping;
import bsql2java.bSQL2Java2.BSQLMachine;
import bsql2java.bSQL2Java2.BSubFalse;
import bsql2java.bSQL2Java2.BSubTrue;
import bsql2java.bSQL2Java2.BTable;
import bsql2java.bSQL2Java2.BType;
import bsql2java.bSQL2Java2.BoolOperation;
import bsql2java.bSQL2Java2.StringOperation;
import bsql2java.bSQL2Java2.VoidOperation;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class BSQL2Java2Generator extends AbstractGenerator {
  private BTable table;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<BSQLMachine> _filter = Iterables.<BSQLMachine>filter(_iterable, BSQLMachine.class);
    for (final BSQLMachine t : _filter) {
      {
        BTable _inv = t.getInv();
        boolean _notEquals = (!Objects.equal(_inv, null));
        if (_notEquals) {
          BTable _inv_1 = t.getInv();
          this.table = _inv_1;
        }
        String _vars = t.getVars();
        String _plus = (_vars + ".java");
        CharSequence _compile = this.compile(t);
        fsa.generateFile(_plus, _compile);
      }
    }
  }
  
  public CharSequence compile(final BSQLMachine m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\t");
    _builder.append("//Generated JAVA code of class ");
    String _m_name = m.getM_name();
    _builder.append(_m_name, "\t");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import java.sql.CallableStatement;");
    _builder.newLine();
    _builder.append("import java.sql.Connection;");
    _builder.newLine();
    _builder.append("import java.sql.ResultSet;");
    _builder.newLine();
    _builder.append("import java.sql.SQLException;\t\t");
    _builder.newLine();
    _builder.append("public class ");
    String _vars = m.getVars();
    _builder.append(_vars, "");
    _builder.append("{\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("private Connection dbcon;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public ");
    String _vars_1 = m.getVars();
    _builder.append(_vars_1, "\t");
    _builder.append("(Connection conn) throws SQLException {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("dbcon = conn;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    {
      EList<BOperation> _bops = m.getBops();
      for(final BOperation o : _bops) {
        CharSequence _compile = this.compile(o);
        _builder.append(_compile, "");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * get the attributes of a table:
   * mode == 0: get all the attributes.
   * mode == 1: get the attributes except the order
   * mode == 2: get the attributes except the user and the order
   */
  public ArrayList<Attribute> getTableAttr(final BTable table, final int mode) {
    final ArrayList<Attribute> listAttrs = new ArrayList<Attribute>();
    EList<Attribute> _attributes = table.getAttributes();
    for (final Attribute attr : _attributes) {
      if ((mode == 0)) {
        listAttrs.add(attr);
      } else {
        if ((mode == 1)) {
          String _att_name = attr.getAtt_name();
          String _string = _att_name.toString();
          boolean _startsWith = _string.startsWith("order");
          boolean _not = (!_startsWith);
          if (_not) {
            listAttrs.add(attr);
          }
        } else {
          if ((mode == 2)) {
            boolean _not_1 = (!(attr.getAtt_name().toString().startsWith("user") || attr.getAtt_name().toString().startsWith("order")));
            if (_not_1) {
              listAttrs.add(attr);
            }
          }
        }
      }
    }
    return listAttrs;
  }
  
  public CharSequence compile(final BOperation o) {
    StringConcatenation _builder = new StringConcatenation();
    {
      BoolOperation _bops = o.getBops();
      boolean _notEquals = (!Objects.equal(_bops, null));
      if (_notEquals) {
        _builder.append(" ");
        BoolOperation _bops_1 = o.getBops();
        CharSequence _compile = this.compile(_bops_1);
        _builder.append(_compile, "");
        _builder.append(" ");
      }
    }
    _builder.newLineIfNotEmpty();
    {
      StringOperation _sops = o.getSops();
      boolean _notEquals_1 = (!Objects.equal(_sops, null));
      if (_notEquals_1) {
        _builder.append(" ");
        StringOperation _sops_1 = o.getSops();
        CharSequence _compile_1 = this.compile(_sops_1);
        _builder.append(_compile_1, "");
        _builder.append(" ");
      }
    }
    _builder.newLineIfNotEmpty();
    {
      VoidOperation _vops = o.getVops();
      boolean _notEquals_2 = (!Objects.equal(_vops, null));
      if (_notEquals_2) {
        _builder.append(" ");
        VoidOperation _vops_1 = o.getVops();
        CharSequence _compile_2 = this.compile(_vops_1);
        _builder.append(_compile_2, "");
        _builder.append(" ");
      }
    }
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final BoolOperation bo) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/**");
    _builder.newLine();
    _builder.append("* automatic generation of the operation ");
    String _op_name = bo.getOp_name();
    _builder.append(_op_name, "");
    _builder.newLineIfNotEmpty();
    _builder.append("**/");
    _builder.newLine();
    _builder.append("public boolean ");
    String _op_name_1 = bo.getOp_name();
    _builder.append(_op_name_1, "");
    _builder.append("(");
    {
      EList<BParameterTyping> _pTyping = bo.getPTyping();
      boolean _hasElements = false;
      for(final BParameterTyping p : _pTyping) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "");
        }
        _builder.append(" ");
        BType _type = p.getType();
        CharSequence _btype2javatype = this.btype2javatype(_type);
        _builder.append(_btype2javatype, "");
        _builder.append(" ");
        String _p_name = p.getP_name();
        _builder.append(_p_name, "");
        _builder.append(" ");
      }
    }
    _builder.append(") {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("CallableStatement stmt;");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("try{");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("//call the stored procedure ");
    String _op_name_2 = bo.getOp_name();
    _builder.append(_op_name_2, "\t \t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("stmt = dbcon.prepareCall(\"{call ");
    String _op_name_3 = bo.getOp_name();
    _builder.append(_op_name_3, "\t\t");
    _builder.append(" (?)}\");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    int index = 0;
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    {
      EList<BParameterTyping> _pTyping_1 = bo.getPTyping();
      for(final BParameterTyping p_1 : _pTyping_1) {
        _builder.append(" stmt.");
        BType _type_1 = p_1.getType();
        CharSequence _btype2jtypeSetting = this.btype2jtypeSetting(_type_1);
        _builder.append(_btype2jtypeSetting, "\t\t");
        _builder.append("(");
        _builder.append(index = (index + 1), "\t\t");
        _builder.append(",");
        String _p_name_1 = p_1.getP_name();
        _builder.append(_p_name_1, "\t\t");
        _builder.append("); ");
      }
    }
    _builder.append("   \t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    {
      BSubTrue _reshas = bo.getReshas();
      boolean _notEquals = (!Objects.equal(_reshas, null));
      if (_notEquals) {
        _builder.append(" ");
        BSubTrue _reshas_1 = bo.getReshas();
        CharSequence _compile = this.compile(_reshas_1);
        _builder.append(_compile, "\t\t");
        _builder.append(" ");
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    {
      BSubFalse _resno = bo.getResno();
      boolean _notEquals_1 = (!Objects.equal(_resno, null));
      if (_notEquals_1) {
        _builder.append(" ");
        BSubFalse _resno_1 = bo.getResno();
        CharSequence _compile_1 = this.compile(_resno_1);
        _builder.append(_compile_1, "\t\t");
        _builder.append(" ");
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("} catch (SQLException e) {e.printStackTrace();}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("return false;");
    _builder.newLine();
    _builder.append("}   \t\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final BSubFalse subf) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//execution of the statement:");
    _builder.newLine();
    _builder.append("//returns true if there is no returned result,");
    _builder.newLine();
    _builder.append("//false otherwise");
    _builder.newLine();
    _builder.append("ResultSet ");
    String _res = subf.getRes();
    _builder.append(_res, "");
    _builder.append(" = stmt.executeQuery();");
    _builder.newLineIfNotEmpty();
    _builder.append("if (");
    String _res_1 = subf.getRes();
    _builder.append(_res_1, "");
    _builder.append(".next() && ");
    String _res_2 = subf.getRes();
    _builder.append(_res_2, "");
    _builder.append(".getInt(1)>0) ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("return false;");
    _builder.newLine();
    _builder.append("else");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("return true;");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final BSubTrue subt) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//execution of the statement:");
    _builder.newLine();
    _builder.append("//returns true if there exists at least a returned result,");
    _builder.newLine();
    _builder.append("//false otherwise");
    _builder.newLine();
    _builder.append("ResultSet ");
    String _res = subt.getRes();
    _builder.append(_res, "");
    _builder.append(" = stmt.executeQuery();");
    _builder.newLineIfNotEmpty();
    _builder.append("if (");
    String _res_1 = subt.getRes();
    _builder.append(_res_1, "");
    _builder.append(".next() && ");
    String _res_2 = subt.getRes();
    _builder.append(_res_2, "");
    _builder.append(".getInt(1)>0) ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("return true;");
    _builder.newLine();
    _builder.append("else");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("return false;");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final StringOperation so) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("   \t\t\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final VoidOperation vo) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/**");
    _builder.newLine();
    _builder.append("* automatic generation of the operation ");
    String _op_name = vo.getOp_name();
    _builder.append(_op_name, "");
    _builder.newLineIfNotEmpty();
    _builder.append("**/");
    _builder.newLine();
    _builder.append("public void ");
    String _op_name_1 = vo.getOp_name();
    _builder.append(_op_name_1, "");
    _builder.append("(");
    EList<BParameterTyping> _pTyping = vo.getPTyping();
    CharSequence _parametersWithType = this.getParametersWithType(_pTyping);
    String _string = _parametersWithType.toString();
    String _replace = _string.replace(",,", ",");
    String _replace_1 = _replace.replace(",/*omit", "/*omit");
    _builder.append(_replace_1, "");
    _builder.append("){");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("//defining a SQL statement to add a new record to the table ");
    String _table_name = this.table.getTable_name();
    _builder.append(_table_name, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("Statement stm = dbcon.createStatement();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("String log = \"INSERT INTO ");
    String _table_name_1 = this.table.getTable_name();
    _builder.append(_table_name_1, "\t\t");
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("+ \"(");
    {
      ArrayList<Attribute> _tableAttr = this.getTableAttr(this.table, 1);
      boolean _hasElements = false;
      for(final Attribute attr : _tableAttr) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(", ", "\t\t\t");
        }
        String _att_name = attr.getAtt_name();
        _builder.append(_att_name, "\t\t\t");
      }
    }
    _builder.append(") \"");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("+ \"VALUES(");
    {
      ArrayList<BParameterTyping> _operationParameters = this.getOperationParameters(vo, 1);
      boolean _hasElements_1 = false;
      for(final BParameterTyping p : _operationParameters) {
        if (!_hasElements_1) {
          _hasElements_1 = true;
        } else {
          _builder.appendImmediate(",", "\t\t\t");
        }
        String _textBParameterTyping = this.toTextBParameterTyping(p);
        _builder.append(_textBParameterTyping, "\t\t\t");
      }
    }
    _builder.append(");\";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("//executing the statement");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("stm.executeUpdate(log);\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("stm.close();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("} catch (SQLException e) {e.printStackTrace();}\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * get the parameters of a void operation:
   * mode == 0: get all the parameters.
   * mode == 1: get the parameters except the time
   */
  public ArrayList<BParameterTyping> getOperationParameters(final VoidOperation vo, final int mode) {
    final ArrayList<BParameterTyping> listAttrs = new ArrayList<BParameterTyping>();
    EList<BParameterTyping> _pTyping = vo.getPTyping();
    for (final BParameterTyping p : _pTyping) {
      if ((mode == 0)) {
        listAttrs.add(p);
      } else {
        if ((mode == 1)) {
          String _p_name = p.getP_name();
          String _string = _p_name.toString();
          boolean _equals = _string.equals("time");
          boolean _not = (!_equals);
          if (_not) {
            listAttrs.add(p);
          }
        }
      }
    }
    return listAttrs;
  }
  
  /**
   * convert a parameter in the VALUES clause (SQL) according to its type
   */
  public String toTextBParameterTyping(final BParameterTyping pType) {
    BType _type = pType.getType();
    CharSequence _btype2javatype = this.btype2javatype(_type);
    String _string = _btype2javatype.toString();
    boolean _equals = _string.equals("String");
    if (_equals) {
      String _p_name = pType.getP_name();
      String _plus = ("\'\"+ " + _p_name);
      return (_plus + " +\"\'");
    } else {
      String _p_name_1 = pType.getP_name();
      String _plus_1 = ("\"+ " + _p_name_1);
      return (_plus_1 + " +\"");
    }
  }
  
  public CharSequence getParametersWithType(final EList<BParameterTyping> list) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _hasElements = false;
      for(final BParameterTyping p : list) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "");
        }
        {
          String _p_name = p.getP_name();
          String _string = _p_name.toString();
          boolean _contains = _string.contains("time");
          if (_contains) {
            CharSequence _btypeTime = this.btypeTime(p);
            _builder.append(_btypeTime, "");
          } else {
            BType _type = p.getType();
            CharSequence _btype2javatype = this.btype2javatype(_type);
            _builder.append(_btype2javatype, "");
            _builder.append(" ");
            String _p_name_1 = p.getP_name();
            _builder.append(_p_name_1, "");
          }
        }
      }
    }
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence btypeTime(final BParameterTyping t) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/*omit the datetime type that is automatically calculated in java/sql*/");
    return _builder;
  }
  
  public CharSequence btype2javatype(final BType t) {
    StringConcatenation _builder = new StringConcatenation();
    String _switchResult = null;
    String _type_name = t.getType_name();
    switch (_type_name) {
      case "NAT":
        _switchResult = "int";
        break;
      case "BOOL":
        _switchResult = "boolean";
        break;
      case "STR":
        _switchResult = "String";
        break;
      case "Users":
        _switchResult = "String";
        break;
      default:
        _switchResult = "int";
        break;
    }
    _builder.append(_switchResult, "");
    return _builder;
  }
  
  public CharSequence btype2jtypeSetting(final BType t) {
    StringConcatenation _builder = new StringConcatenation();
    String _switchResult = null;
    String _type_name = t.getType_name();
    switch (_type_name) {
      case "NAT":
        _switchResult = "setInt";
        break;
      case "BOOL":
        _switchResult = "setBoolean";
        break;
      case "STR":
        _switchResult = "setString";
        break;
      default:
        _switchResult = "setInt";
        break;
    }
    _builder.append(_switchResult, "");
    return _builder;
  }
}
