/*
 * generated by Xtext 2.10.0
 */
package secureuml2Java.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import secureuml2Java.secureUML2Java.BMachine

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SecureUML2JavaGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (t : resource.allContents.toIterable.filter(BMachine)) {
            fsa.generateFile("SecureUMLJAVATrans.java", t.compile)
        }
}

def compile(BMachine m)'''
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class SecureUMLJAVATrans {
	private String connectingUser;
	private String currentRole;
	private Connection dbcon;
	public void connectUser(String usr, String  rol) 
	{
		connectingUser = usr;
		currentRole = rol;
	}
	public String checkUserPermission(String usr, String op) throws SQLException 
	{
		String access = "denied";
		//getting the connecting user,
		//making sure that the verified user is currently 
		//connecting to the system.
		String conUser = getConnectingUser();
		if (usr.equals(conUser)) {
			//checking the permission based on the current role of the user,
			//the execution is granted if the method isPermittedRole()
			// returns true, denied otherwise.
			boolean isPermitted = isPermittedRole(currentRole, op);
			if (isPermitted)
				access = "granted";
			else
				access = "denied";
		}
		return access;
	}
	
	//checking the execution permission of a given role on a given method	
	public boolean isPermittedRole(String rol, String op) throws SQLException 
	{
		boolean access = false;
		//defining a PreparedStatement JAVA variable to verify 
		//permission of a given role on executing a given stored procedure
		PreparedStatement stm = dbcon.prepareStatement("SELECT COUNT(*)"
			+ "FROM sys.database_permissions "
			+ "WHERE USER_NAME(grantee_principal_id) = (?) "
			+ "AND OBJECT_NAME(major_id) = (?) "
			+ "AND permission_name = 'EXECUTE';");
		try {
			stm.setString(1, rol);
			stm.setString(2, op);
			//the execution of the statement,
			//returns true if there exists at least one row in the database,
			//returns false otherwise.
			ResultSet resSet = stm.executeQuery();
			if (resSet.next() && resSet.getInt(1) > 0)
				access = true;
			resSet.close();
		} catch (SQLException e) {e.printStackTrace();}
		return access;
	}
	
	private String getConnectingUser() {
		return connectingUser;
	}
}
    '''
}
