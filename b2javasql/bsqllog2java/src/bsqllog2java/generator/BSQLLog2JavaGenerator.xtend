/*
 * generated by Xtext 2.10.0
 */
package bsqllog2java.generator

import bsqllog2java.bSQLLog2Java.BSQLMachine
import bsqllog2java.bSQLLog2Java.BType
import bsqllog2java.bSQLLog2Java.BoolOperation
import bsqllog2java.bSQLLog2Java.VoidOperation
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import bsqllog2java.bSQLLog2Java.StringOperation
import bsqllog2java.bSQLLog2Java.BOperation
import bsqllog2java.bSQLLog2Java.BSubFalse
import bsqllog2java.bSQLLog2Java.BSubTrue
import bsqllog2java.bSQLLog2Java.BParameterTyping
import org.eclipse.emf.common.util.EList
import bsqllog2java.bSQLLog2Java.BTable
import java.util.ArrayList
import bsqllog2java.bSQLLog2Java.Attribute

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BSQLLog2JavaGenerator extends AbstractGenerator {

	BTable table; 
	
override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (t : resource.allContents.toIterable.filter(BSQLMachine)) {
            if(t.inv != null)
            	table = t.inv;
            fsa.generateFile(
                t.vars + ".java", t.compile)
            
        }
	}
	
	
	
	def compile(BSQLMachine m)'''
		//Generated JAVA code of class «m.m_name»
		import java.sql.Connection;
		import java.sql.PreparedStatement;
		import java.sql.ResultSet;
		import java.sql.SQLException;
		import java.sql.Statement;
		
		public class «m.vars»{			
			private Connection dbcon;
			private PreparedStatement stmt;

			public «m.vars»(Connection conn) throws SQLException {
					dbcon = conn;
					stmt = conn.prepareStatement("SELECT *"
						+ "FROM «table.table_name» " 
						+ "WHERE «FOR attr:getTableAttr(table,2) SEPARATOR " AND "»«attr.att_name»=?«ENDFOR»; ");	
			}
			«FOR o : m.bops»
	    	    «o.compile»
	    	«ENDFOR»	    	
«««	    	«FOR o : m.vops»
«««	    		 «o.compile»
«««	    	«ENDFOR»
«««	    	«FOR o : m.sops»
«««	    		«o.compile»
«««	    	«ENDFOR»
	}
    '''
/**
 * get the attributes of a table:
 * mode == 0: get all the attributes.
 * mode == 1: get the attributes except the order
 * mode == 2: get the attributes except the user and the order
 */
	def getTableAttr(BTable table, int mode) {
		val ArrayList<Attribute>  listAttrs = new ArrayList<Attribute>()
		for(Attribute attr: table.attributes){
			if(mode == 0){
				listAttrs.add(attr)
			}
			else if(mode == 1){
				if(!attr.att_name.toString().startsWith("order")){
					listAttrs.add(attr)
				}
			}
			else if(mode == 2){
				if(!(attr.att_name.toString().startsWith("user")||attr.att_name.toString().startsWith("order"))){
					listAttrs.add(attr)
				}
			}			
		}
		return listAttrs
	}
	
    def compile(BOperation o)'''
    	«IF o.bops != null» «o.bops.compile» «ENDIF»
    	«IF o.sops != null» «o.sops.compile» «ENDIF»
    	«IF o.vops != null» «o.vops.compile» «ENDIF»
    '''
    
    
    def compile (BoolOperation bo)'''
	/**
	* automatic generation of the operation «bo.op_name»
	**/
	public boolean «bo.op_name»(«FOR p : bo.PTyping SEPARATOR ','» «p.type.btype2javatype» «p.p_name» «ENDFOR») {
		try {
			«var index = 0»
			«FOR p : bo.PTyping» stmt.«p.type.btype2jtypeSetting»(«index = index + 1»,«p.p_name»); «ENDFOR»   			
			«IF bo.reshas != null» «bo.reshas.compile» «ENDIF»
			«IF bo.resno != null» «bo.resno.compile» «ENDIF»
		} catch (SQLException e) {e.printStackTrace();}
		return false;
	}   		
   '''
      
   def compile(BSubFalse subf)'''
	//execution of the statement that checks if the method 
	//is already performed or not,
	//returns false if it is already executed, true otherwise.
	ResultSet «subf.res» = stmt.executeQuery();
	if («subf.res».next()) 
		return false;
	else
		return true;
   '''
   
      def compile(BSubTrue subt)'''
	//execution of the statement that checks if the method 
	//is already performed or not,
	//returns true if it is already executed, false otherwise.
	ResultSet «subt.res» = stmt.executeQuery();
	if («subt.res».next()) 
		return true;
	else
		return false;
   '''
   
       def compile (StringOperation so)'''
   			
   '''
      
    def compile(VoidOperation vo)'''
    	/**
    	* automatic generation of the operation «vo.op_name»
    	**/
    	public void «vo.op_name»(«getParametersWithType(vo.PTyping).toString().replace(',,',',').replace(',/*omit','/*omit')»){
    		try {
    			//defining a SQL statement to add a new record to the table «table.table_name»
    			Statement stm = dbcon.createStatement();
    			String log = "INSERT INTO «table.table_name»"
    				+ "(«FOR attr:getTableAttr(table,1) SEPARATOR ", "»«attr.att_name»«ENDFOR») "
    				+ "VALUES(«FOR p: getOperationParameters(vo,1) SEPARATOR","»«toTextBParameterTyping(p)»«ENDFOR»);";
    			//executing the statement
    			stm.executeUpdate(log);			
    			stm.close();
    		} catch (SQLException e) {e.printStackTrace();}	
    	}
    '''
    
 /**
 * get the parameters of a void operation:
 * mode == 0: get all the parameters.
 * mode == 1: get the parameters except the time
 */
	def getOperationParameters(VoidOperation vo, int mode) {
		val ArrayList<BParameterTyping>  listAttrs = new ArrayList<BParameterTyping>()
		for(BParameterTyping p: vo.PTyping){
			if(mode == 0){
				listAttrs.add(p)
			}
			else if(mode == 1){
				if(!p.p_name.toString().equals("time")){
					listAttrs.add(p)
				}
			}		
		}
		return listAttrs
	}
	
	/**
	 * convert a parameter in the VALUES clause (SQL) according to its type
	 */
	def toTextBParameterTyping(BParameterTyping pType) {
		if(btype2javatype(pType.type).toString().equals("String")){
			return "'\"+ "+pType.p_name+" +\"'"
		}else{
			return "\"+ "+pType.p_name+" +\""
		}
	}
	
	def getParametersWithType(EList<BParameterTyping> list)'''
		«FOR p : list SEPARATOR ','»«IF p.p_name.toString.contains("time")»«p.btypeTime»«ELSE»«p.type.btype2javatype» «p.p_name»«ENDIF»«ENDFOR»
	'''
	
   	def btypeTime(BParameterTyping t)'''
   	/*omit the datetime type that is automatically calculated in java/sql*/'''
   	
       def btype2javatype(BType t)'''«switch t.type_name{
    		case 'NAT': 'int'
    		case 'BOOL': 'boolean'
    		case 'STR': 'String'
    		case 'Users': 'String'
    		default: 'int' 	
    	}»''' 
    
    def btype2jtypeSetting(BType t)'''«switch t.type_name{
    		case 'NAT': 'setInt'
    		case 'BOOL': 'setBoolean'
    		case 'STR': 'setString'
    		default: 'setInt' 	
    	}»''' 

}

